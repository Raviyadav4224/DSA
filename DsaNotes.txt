1. Digits - 
	If division is by 10 - time complexity - log10(N)
	If division is by 2 - time complexity - log2(N)
	If division is by 5 - time complexity - log5(N)
	If division is by 7 - time complexity - log7(N)

2. Divisors -
	
	best time complexity - O(sqrt(N))

	************** GCD **************** 
	gcd(a,b)=gcd(a%b,b)
	or 
	gcd(greater,smaller)=gcd(greater%smaller)

	Method->
	public static int gcd(int greater, int smaller) {

        while (greater > 0 && smaller > 0) {
            if (greater > smaller) {
                greater = greater % smaller;
            } else {
                smaller = smaller % greater;
            }
        }
        if (greater == 0) {
            return smaller;
        }
        return greater;
    }
	time complexity - O(log to the base fyi (MIN(a,b)))
	not to the base 10, since it depends upon a,b

	************** LCM ****************

	lcm= (a*b) / gcd(a,b)

3. Prime numbers-

	has exactly two factors - 1 and itself

	Best approach - O(sqrt(N))

	for(i=1;i<=Math.sqrt(N);i++)
	or
	for(i=1;i*i<=N;i++)

	if(N%i==0){
		if(N/i!=1) // since 6/6 =1 and factors will repeat
	}


4. Recursion - 
	When a function calls itself and terminates on a base condition

5. Reversing & Palindrome -

	Reversing(Time complexity - O(N))
		1. using Loops -
			swap left and right elements
			for (int i = 0; i <= a.length / 2; i++) {
				swap(a, i, a.length - 1 - i);
			}
			Time complexity - O(N)

		2. using Recursion -
			if (left >= a.length / 2) {
				return;
			}
			swap(a, left, a.length-1-left);
			reverse(a, left+1);
			
	Palindrome(Time complexity - O(N))
		1.using Loops - 
			public static boolean isPalindromeLoop(String s){
			System.err.println("input is "+s);
			for(int i=0;i<s.length()/2;i++){
				if(s.charAt(i)!=s.charAt(s.length()-1-i)){
					return false;
				}
			}
			return true;
			}
		
		2. using Recursion -
			public static boolean isPalindromeRec(String s, int left, int right) {
			if (left >= right) {
				return true;
			}
			if (s.charAt(left) != s.charAt(right)) {
				return false;
			}
			return isPalindromeRec(s, left + 1, right - 1);
		}
6. Hashing -
	It is done to calculate frequencies of say a digit in an array

	Brute force approach ->
	public static void hashing(int arr[], int hash[]) {

        for (int i = 0; i < arr.length; i++) {
            hash[arr[i]] += 1;
        }
    }
	TimeComplexity - O(N)
	SpaceComplexity - O(k) where k is distinct values stored in the Array

	*TreeMap: Fetching: O(log n) - an ordered map
	*HashMap (Fetching: O(1))is an example of an unordered map

7. Sorting -

	Selection sort ->
		[12,2,10,15,20]
		Set the first element as minimum
		Compare minimum with the second element. 
		If the second element is smaller than minimum, assign the second element as minimum.
		Compare minimum with the third element. Again, if the third element is smaller,
		then assign minimum to the third element otherwise do nothing. 
		he process goes on until the last element.
			for (int i = 0; i < arr.length - 1; i++) {
            int min = i;
            for (int j = i + 1; j < arr.length; j++) {
                if (arr[j] < arr[min]) {
                    min = j;
                }
            }
            System.out.println("swapping " + i + min);
            swap(arr, i, min);
        }
		TimeComplexity - O(N^2)
		SpaceComplexity -O(1)

	Bubble sort ->
		Compare and Swap
		1. First Iteration (Compare and Swap)
		Starting from the first index, compare the first and the second elements.
		If the first element is greater than the second element, they are swapped.
		Now, compare the second and the third elements. Swap them if they are not in order.
		The above process goes on until the last element

			 for (int i = 0; i < arr.length - 1; i++) {
            for (int j = 0; j < arr.length - 1 - i; j++) {
                if (arr[j] > arr[j + 1]) {
                    swapped = true;
                    swap(arr, j, j + 1);
                }
            }
            if (!swapped) {
                return;
            }
        }
		TimeComplexity - O(N^2)
		Best TimeComplexity - O(N)
		SpaceComplexity -O(1)

	Insertion sort ->
			public static void insertionSort(int[] input) {
			for (int i = 0; i < input.length ; i++) {
				int j = i;
				while (j > 0 && input[j] < input[j - 1]) {
					swap(input, j, j - 1);
					j--;
				}
			}
		}
		TimeComplexity - O(N^2)
		Best TimeComplexity - O(N)
		SpaceComplexity -O(1)

	Merge sort ->
		This is based on DIVIDE & CONQUER/MERGE
		MergeSort(Array, low,high){
			if(low>=high) return;
			middle=(low+high)/2;
			MergeSort(Array,low,middle)
			MergeSort(Array,middle+1,high)
			Merge(Array,low,mid,high)
		}
			public static void mergeSort(int a[], int low, int high) {
			if (low >= high) {
				return;
			}
			int mid = (low + high) / 2;

			mergeSort(a, low, mid);
			mergeSort(a, mid + 1, high);
			merge(a, low, mid, high);

		}

		public static void merge(int[] a, int low, int mid, int high) {
			int result[] = new int[high-low+1];
			int left = low;
			int right = mid + 1;
			int index = 0;
			while (left <= mid && right <= high) {
				if (a[left] <= a[right]) {
					result[index] = a[left];
					left++;
				} else {
					result[index] = a[right];
					right++;
				}
				index++;
			}
			while (left <= mid) {
				result[index] = a[left];
				left++;
			}
			while (right <= high) {
				result[index] = a[right];
				right++;
			}
			for (int i = low; i <= high; i++) {
				a[i] = result[i - low];
			}
		}
		TimeComplexity-> O(N*log N to base 2)
		SpaceComplexity-> O(N)

	Quick sort ->
		TimeComplexity-> O(N*log N to base 2)
		SpaceComplexity-> O(N)


8. Arrays ->
	1. Easy ->
		LargestElement ->
			1. Brute force approach -> sort & show the last element(which will be the largest element)
				TimeComplexity - nlogn+n;
			2. Optimal approach -> loop the whole array and compare the largest element
					public static int largestElement(int a[]) {
						int largest = a[0];
						for (int i = 1; i < a.length; i++) {
							if (a[i] > largest) {
								largest = a[i];
							}
						}
						return largest;
					}
					TimeComplexity - O(N);

		2nd LargestElement -> 
			1. Brute force approach -> sort & show the 2nd last element(which will be the 2nd largest element)
				TimeComplexity - nlogn+n;
			2. Better approach -> loop the whole array and first find the largest element and then loop and check for 2nd largest element
				public static int secondLargest(int a[]) {
					int sLargest = -1;
					int largest = a[0];

					for (int i = 0; i < a.length; i++) {
						if (a[i] > largest) {
							largest = a[i];
						}
					}
					for (int i = 0; i < a.length; i++) {
						if (a[i] > sLargest && a[i] != largest) {
							sLargest = a[i];
						}
					}
					return sLargest;
				}
				TimeComplexity - O(N+N)= O(2N)

			3. Optimal approach -> loop the whole array and first find the largest element and check for 2nd largest element
			public static int secondLargest(int a[]) {
				int sLargest = -1;
				int largest = a[0];

				for (int i = 0; i < a.length; i++) {
				if (a[i] > largest) {
					sLargest = largest;
					largest = a[i];
				} else if (a[i] < largest && a[i] > sLargest) {
					sLargest = a[i];
				}
			}
				return sLargest;
			}
			TimeComplexity - O(N+N)= O(N)

		Array is sorted or not -> 
			public static boolean isArraySorted(int a[]) {
				for (int i = 0; i < a.length - 1; i++) {
					if (a[i + 1] < a[i]) {
						return false;
					}
				}
				return true;
			}
			TimeComplexity -> O(N)

		Remove duplicates -> 
		*Change the array nums such that the first k elements of nums contain the unique elements in 
		the order they were present in nums initially. The remaining elements of nums are not important 
		as well as the size of nums.

			1. Brute force approach ->
				loop and store each element in a Set(which contains unique elements), then
				loop through the Set and store the values back in the array
				public static int removeDuplicates(int a[]) {
					int k = 0;
					HashSet<Integer> set = new HashSet<>();
					for (int i = 0; i < a.length; i++) {
						set.add(a[i]);
					}

					int i = 0;
					for (Integer integer : set) {
						a[i] = integer;
						i++;
					}
					k = set.size();
					return k;
					}
					TimeComplexity -> O(N+N)=O(N)
					SpaceComplexity -> O(N)

			2. Optimal approach -> 
				Two pointer approach
				public static int removeDuplicates2pointer(int a[]) {
				int i = 0;
				for (int j = 1; j < a.length; j++) {
					if (a[j] != a[i]) {
						a[i + 1] = a[j];
						i++;
					}
				}
				return i + 1;
				}
				TimeComplexity -> O(N)
				SpaceComplexity -> O(1)

		Left Rotate Array ->
			Left rotate by one place ->
				public static void leftRotateArrayByOne(int arr[]) {
					int temp = arr[0];
					for (int i = 1; i < arr.length; i++) {
						arr[i - 1] = arr[i];
					}
					arr[arr.length - 1] = temp;
				}
				TimeComplexity - > O(N)
				SpaceComplexity -> O(1)
				
			Left rotate by K places ->
				public static void leftRotateByKPlaces(int arr[], int k) {
					int temp[] = new int[k];
					k = k % arr.length;

					for (int i = 0; i < k; i++) {
						temp[i] = arr[i];
					}

					for (int i = k; i < arr.length; i++) {
						arr[i - k] = arr[i];
					}

					for (int i = arr.length - k; i < arr.length; i++) {
						arr[i] = temp[i - (arr.length - k)];
					}
				}
				TimeComplexity -> O(N-K)+O(K)+O(K) => O(N+K)
				SpaceComplexity -> O(K)

				Another approach -> using Reversing

				reverse(arr,arr+d)
				reverse(arr+d,arr+n)
				reverse(arr,arr+n)

				TimeComplexity - O(d)+O(n-d)+O(n) => O(2n)
				SpaceComplexity -> O(1)

		Move zeros to the end of array ->

			1. Brute force approach -
				Iterate and store all the non zero elements in temp array
				then store back by overwriting in the original array and fill rest with zeros
					public static void moveZeroesToTheEnd(int arr[]) {
						List<Integer> temp = new ArrayList<>();
						for (int i = 0; i < arr.length; i++) {
							if (arr[i] != 0) {
								temp.add(arr[i]);
							}
						}
						for (int i = 0; i < arr.length; i++) {
							if (i < temp.size()) {
								arr[i] = temp.get(i);
							} else {
								arr[i] = 0;
							}
						}
					}
					TimeComplexity -> O(n)+O(n)= O(2n)
					SpaceComplexity -> O(N)

			2. Optimal approach -> Two pointer approach
				public static void moveZeroesToTheEnd2Pointer(int arr[]) {
					int j = -1;
					for (int index = 0; index < arr.length; index++) {
						if (arr[index] == 0) {
							j = index;
							break;
						}
					}
					if (j == -1) {
						System.out.println("No zeroes are there in the Array");
						return;
					}
					for (int i = j + 1; i < arr.length; i++) {
						if (arr[i] != 0) {
							swap(arr, j, i);
							j++;
						}
					}
				}
				TimeComplexity -> O(x)+O(n-x) => O(n)
				SpaceComplexity -> O(1)

		Linear Search ->
			public static int linearSearch(int arr[], int num) {
				int pos = -1;
				for (int i = 0; i < arr.length; i++) {
					if (arr[i] == num) {
						return pos = i;
					}
				}
				return pos;
			}
			TimeComplexity -> O(n)
			SpaceComplexity -> O(1)
		
		Union of two SORTED Arrays -> 
			Brute force approach ->
				Loop through both the arrays and store in SET which contains unique elements
				TimeComplexity -> O(n1)+O(n2)+O(n1+n2)= O(2*(n1+n2))
				SpaceComplexity -> O(n1+n2)
			
			Optimal approach ->
				Two pointer approach
				TimeComplexity -> O(n1+n2)
				SpaceComplexity -> O(n1+n2) || O(1)
				public static void unionTwoArrays(int arr1[], int arr2[]) {

					int i = 0, j = 0;
					List<Integer> union = new ArrayList<>();

					while (i < arr1.length && j < arr2.length) {

						if (arr1[i] <= arr2[j]) {
							if (union.size() == 0 || union.get(union.size() - 1) != arr1[i]) {
								union.add(arr1[i]);
							}
							i++;
						} else {
							if (union.size() == 0 || union.get(union.size() - 1) != arr2[j]) {
								union.add(arr2[j]);
							}
							j++;
						}
					}

					while (i < arr1.length) {
						if (union.size() == 0 || union.get(union.size() - 1) != arr1[i]) {
							union.add(arr1[i]);
						}
						i++;
					}
					while (j < arr2.length) {
						if (union.size() == 0 || union.get(union.size() - 1) != arr2[j]) {
							union.add(arr2[j]);
						}
						j++;
					}
					System.out.println(union);
					return union;
				}

		Intersection of two SORTED Array ->

			TimeComplexity ->O(n1+n2)
			SpaceComplexity ->O(n1+n2)
			Optimal approach ->
				Two pointer approach
				public static List<Integer> intersection2pointer(int arr1[], int arr2[]) {
					List<Integer> intersection = new ArrayList<>();
					int n1 = arr1.length;
					int n2 = arr2.length;

					int i = 0, j = 0;

					while (i < n1 && j < n2) {
						if (arr1[i] > arr2[j]) {
							j++;
						} else if (arr1[i] < arr2[j]) {
							i++;
						} else {
							intersection.add(arr1[i]);
							i++;
							j++;
						}
					}

					return intersection;
				}
		
		Missing Number ->
			For N numbers
			Brute force approach ->
				check every number and check whether present or not using Linear search 
				public static int missingNumber(int arr[], int n) {
					for (int i = 1; i <= n; i++) {
						boolean flag = false;
						for (int j = 0; j < arr.length; j++) {
							if (arr[j] == i) {
								flag = true;
								break;
							}
						}
						if (flag == false) {
							return i;
						}
					}
					return 0;
				}
				TimeComplexity ->O(N^2)
				SpaceComplexity -> O(1)

			Better approach ->
				using Hashing
				TimeComplexity -> O(N)+O(N) = O(2N)
				SpaceComplexity -> O(N)
				public static int missingNumberHashing(int arr[], int n) {
					int hash[] = new int[n + 1];

					for (int i = 0; i < arr.length; i++) {
						hash[arr[i]] = hash[arr[i]] + 1;
					}
					for (int i = 1; i < hash.length; i++) {
						if (hash[i] == 0) {
							return i;
						}
					}
					return 0;
				}

			Optimal approach ->

				1. By finding Summation 
					TimeComplexity -> O(N)
					SpaceComplexity -> O(1)
					public static int missingNumberSummation(int arr[], int n) {

						int actualSum = (n * (n + 1)) / 2;
						int sum = 0;
						for (int i = 0; i < arr.length; i++) {
							sum = sum + arr[i];
						}

						return actualSum - sum;
					}
				
				2. using XOR ->
					5 xor 5 => 5
					AnyNumber xor 0=> AnyNumber
					TimeComplexity -> O(N)
					SpaceComplexity -> O(1)
						public static int missingNumberXOR(int arr[], int n) {
							int xor1 = 0;
							int xor2 = 0;
							for (int i = 0; i < n - 1; i++) {
								xor1 = xor1 ^ (i + 1);
								xor2 = xor2 ^ arr[i];
							}
							xor1 = xor1 ^ n;
							return xor1 ^ xor2;
						}

		Maximum consecutive ones ->

			Optimal approach ->
				public static void maximumConsecutiveOnes(int arr[]) {
					int count = 0;
					int max = 0;
					for (int i = 0; i < arr.length; i++) {
						if (arr[i] == 1) {
							count++;
							max = Math.max(max, count);
						} else {
							count = 0;
						}
					}
					System.out.println("consecutive ones are " + max);
				}
		
		Find the numbers that appear ones and others twice ->
			* Here all other numbers appears twice except one
			Brute force approach ->
				Same as finding missing number
				TimeComplexity -> O(N^2)

			Better approach ->
				using hashing
			
			Optimal approach ->
				using xor

		Longest Subarray with given sum K ->

			1. Brute force approach -> 
				Generate all subarrays and then find sum 
				Generate subarray ->
					public static void LongestSubArray(int arr[], int d) {
						int longestLength = 0;
						for (int i = 0; i < arr.length; i++) {
							for (int j = i; j < arr.length; j++) {
								// Summation
								int sum = 0;
								for (int k = i; k <= j; k++) {
									sum = sum + arr[k];
								}

								if (sum == d) {
									longestLength = Math.max(longestLength, j - i + 1);
								}
							}
						}
						System.out.println(longestLength);
					}
					TimeComplexity -> O(N^3)
					SpaceComplexity -> O(1)

				OR

				public static void LongestSubArray(int arr[], int d) {
						int longestLength = 0;
						for (int i = 0; i < arr.length; i++) {
								int sum = 0;
							for (int j = i; j < arr.length; j++) {
								if (sum == d) {
									longestLength = Math.max(longestLength, j - i + 1);
								}
							}
						}
						System.out.println(longestLength);
					}
					TimeComplexity -> O(N^2)
					SpaceComplexity -> O(1)
					
			2. Better approach ->
				using Hashing
					1. We will sum from zero index to the end and store it in HashMap
					2. If sum is equal to K then maxLength would be i+1
					3. Remaining would be sum-K
					4. If remaining is already present in HashMap we need to check whether it is max or not
						newLength = i- HashMap(remaining)
						maxLength=Max(maxLength,newLength)

					public static int LongestSubArrayUsingHashing(int arr[], int k) {

						HashMap<Integer, Integer> prefixSum = new HashMap<Integer, Integer>();
						int sum = 0;
						int maxLength = 0;
						for (int i = 0; i < arr.length; i++) {
							sum = sum + arr[i];

							if (sum == k) {
								maxLength = i + 1;
							}

							int remaining = sum - k;
							if (prefixSum.containsKey(remaining)) {
								int len = i - prefixSum.get(remaining);
								maxLength = Math.max(maxLength, len);
							}

							if (!prefixSum.containsKey(sum)) {
								prefixSum.put(sum, i);
							}
						}
						return maxLength;
					}
					TimeComplexity -> O(N)
					SpaceComplexity -> O(N)
				
			3. Optimal approach ->
				Two pointer approach
					public static int LongestSubArrayUsing2Pointer(int arr[], int k) {
						int sum = 0;
						int maxLength = 0;
						int i = 0;
						int j = 0;
						while (j < arr.length) {
							sum = sum + arr[j];
							if (sum == k) {
								maxLength = Math.max(maxLength, j - i + 1);
							}
							while (sum > k && i <= j) {
								sum = sum - arr[i];
								i++;
							}
							j++;
						}

						return maxLength;
					}
					TimeComplexity -> O(n)
					SpaceComplexity -> O(1)

	2. Medium ->

		2Sum Problem ->
			Brute force approach -> Loop and check using every element
				TimeComplexity -> O(N^2)
				SpaceComplexity -> O(1)
				public static boolean TwoSumEqualToTargetK(int arr1[], int target) {
					boolean isEqualToTarget = false;
					for (int i = 0; i < arr1.length; i++) {

						// for (int j = 0; j < arr1.length; j++) {
						//     if (i == j)
						//         continue;
						//     if (arr1[i] + arr1[j] == target) {
						//         isEqualToTarget = true;
						//         System.out.println("index are " + i + " " + j);
						//     }
						// }
						for (int j = i+1; j < arr1.length; j++) {
							if (arr1[i] + arr1[j] == target) {
								isEqualToTarget = true;
								System.out.println("index are " + i + " " + j);
							}
						}
					}
					return isEqualToTarget;
				}
			
			Better approach -> using Hashing
				TimeComplexity -> O(N)
				SpaceComplexity -> O(N)
				public static void TwoSumEqualToTargetKUsingHashing(int arr[], int target) {
					HashMap<Integer, Integer> sum = new HashMap<>();
					int ans[] = { -1, -1 };
					for (int i = 0; i < arr.length; i++) {
						int required = target - arr[i];

						if (sum.containsKey(required)) {
							ans[0] = sum.get(required);
							ans[1] = i;
						}
						sum.put(arr[i], i);
					}

					System.out.println(ans[0] + " " + ans[1]);
				}
			
			*Optimal approach -> Using Two pointer approach but works for sorted arrays
				TimeComplexity -> O(N) + O(N logN)for sorting
				SpaceComplexity -> O(N) for storing sorted array
				public static void TwoSumEqualToTargetKUsing2Pointer(int arr[], int target) {
					int sum = 0, left = 0, right = arr.length - 1;
					while (left < right) {
						sum = arr[left] + arr[right];
						if (sum == target) {
							System.out.println("Sum match found" + left + " " + right);
							left++;
						} else if (sum > target) {
							right--;
						} else if (sum < target) {
							left++;
						}
					}

				}

		Sort an Array of 0s,1s and 2s ->
			Brute force approach -> using sorting Merge sort
				TimeComplexity - > O(nlogN)
				SpaceComplexity -> O(N)
			
			Better approach -> calcualte the numbers of 0s,1s,2s and add them by looping 
				TimeComplexity -> O(N+N)=O(2N)
				SpaceComplexity -> O(1)
				  public static void merge012s(int arr[]) {
						int zeroes = 0, ones = 0, twos = 0;
						for (int i = 0; i < arr.length; i++) {
							if (arr[i] == 0) {
								zeroes++;
							} else if (arr[i] == 1) {
								ones++;
							} else {
								twos++;
							}
						}

						System.out.println("z o t " + zeroes + ones + twos);
						for (int i = 0; i < zeroes; i++) {
							arr[i] = 0;
						}
						for (int i = zeroes; i < (zeroes + ones); i++) {
							arr[i] = 1;
						}
						for (int i = zeroes + ones; i < (zeroes + ones + twos); i++) {
							arr[i] = 2;
						}
						logArray(arr);
					}
		
			Optimal approach -> Using Dutch National Flag Algorithm (DNF Algorithm)
				TimeComplexity -> O(N+N)=O(N)
				SpaceComplexity -> O(1)
				It uses three pointers
				public static void dutchNationFlagAlgorithm(int arr[]) {
					int low = 0, mid = 0, high = arr.length - 1;
					while (mid <= high) {

						if (arr[mid] == 0) {
							swap(arr, mid, low);
							low++;
							mid++;
						}
						else if (arr[mid] == 1) {
							mid++;
						}
						else if (arr[mid] == 2) {
							swap(arr, mid, high);
							high--;
						}
					}
					logArray(arr);
				}

		Majority Element > N/2 times ->
			1. Brute force approach ->
				TimeComplexity -> O(N^2)
				SpaceComplexity -> O(1)
				using nested Loops
					public static int majorityElementNBy2(int arr[]) {
					for (int i = 0; i < arr.length; i++) {
						int count = 0;
						for (int j = 0; j < arr.length; j++) {
							if (arr[j] == arr[i]) {
								count++;
							}
						}
						if (count > arr.length / 2) {
							return arr[i];
						}
					}
					return -1;
				} 
			
			2. Better approach -> 
				using hashing
				TimeComplexity -> O(N+N) => O(2N)
				SpaceComplexity -> O(N)
				public static int majorityElementNBy2UsingHashing(int arr[]) {
					HashMap<Integer, Integer> freq = new HashMap<>();
					for (int i = 0; i < arr.length; i++) {
						if (freq.containsKey(arr[i])) {
							freq.put(arr[i], freq.get(arr[i]) + 1);
						} else {
							freq.put(arr[i], 1);
						}
					}
					System.out.println(freq);
					for (Map.Entry<Integer, Integer> it : freq.entrySet()) {
						if (it.getValue() > (arr.length / 2)) {
							return it.getKey();
						}
					}
					return -1;
				}

			3. Optimal approach -> using Moore's voting Algorithm

				TimeComplexity ->O(N) or O(2N)
				SpaceComplexity -> O(1)
				public static void mooreVotingAlgorithm(int arr[]) {
					int count = 0;
					int element = 0;
					for (int i = 0; i < arr.length; i++) {
						if (count == 0) {
							count = 1;
							element = arr[i];
						} else if (arr[i] != element) {
							count--;
						} else if (arr[i] == element) {
							count++;
						}
					}

					// if given that the array contains majority element this step is not required
					int count1 = 0;
					for (int i = 0; i < arr.length; i++) {
						if (arr[i] == element) {
							count1++;
						}
					}
					if (count1 > arr.length / 2) {
						System.out.println("Majority element is " + element);
					} else {
						System.out.println("No majority element");
					}
				}

		Maximum subarray sum / Kadane's Algorithm ->
			1. Brute force approach ->
				TimeComplexity -> O(N)
				SpaceComplexity -> O(1)
				two loops same as Longest subarray with Sum k
			
			2. Optimal approach -> Kadane's Algorithm
				TimeComplexity -> O(N)
				SpaceComplexity -> O(1)
				public static void KadaneAlgorithm(int arr[]) {
					int max = Integer.MIN_VALUE, sum = 0, start = 0, startIndex = -1, endIndex = -1;

					for (int i = 0; i < arr.length; i++) {
						if (sum == 0) {
							start = i;
						}
						
						sum += arr[i];

						if (sum > max) {
							max = sum;
							startIndex = start;
							endIndex = i;
						}
						
						if (sum < 0) {
							sum = 0;
						}
					}
					System.out.println("Maximum subarray sum is " + max);
					System.out.println("Start index and end index is" + startIndex + " " + endIndex);
				}
		
		Best time to Buy & Sell stocks ->
			First you need to buy and then sell the stock and can be done only once
				Optimal approach ->
				TimeComplexity -> O(N)
				SpaceComplexity -> O(1)
				public static void buySellStocks(int arr[]) {

					int min = arr[0], profit = 0, cost = 0;

					for (int i = 1; i < arr.length; i++) {

						cost = arr[i] - min;
						profit = Math.max(cost, profit);
						min = Math.min(min, arr[i]);
					}
					System.out.println("Maximum profitn is " + profit);
				}

		Rearrange array elements by sign ->
			constraints array must start with positive values
			array is of even size
			array contains equalt number of positives and negatives

			1. Brute force approach ->
				TimeComplexity -> O(N + N/2)
				SpaceComplexity -> O(N/2 +N/2) = O(N)
				public static void rearrangeArray(int arr[]) {
					// [3,1,-2,-5,2,-4]
					List<Integer> pos = new ArrayList<>();
					List<Integer> neg = new ArrayList<>();
					for (int i = 0; i < arr.length; i++) {
						if (arr[i] > 0) {
							pos.add(arr[i]);
						} else {
							neg.add(arr[i]);
						}
					}

					for (int i = 0; i < arr.length / 2; i++) {
						arr[2 * i] = pos.get(i);
						arr[2 * i + 1] = neg.get(i);
					}
					logArray(arr);
				}
			2. Optimal approach ->
					TimeComplexity -> O(N)
					SpaceComplexity -> O(N)
				 	public static void rearrangeArrayOptimal(int arr[]) {

						int ans[] = new int[arr.length];
						// [3,1,-2,-5,2,-4]
						int pos = 0;
						int neg = 1;
						for (int i = 0; i < arr.length; i++) {
							if (arr[i] > 0) {
								ans[pos] = arr[i];
								pos += 2;
							} else {
								ans[neg] = arr[i];
								neg += 2;
							}
						}
						logArray(ans);
					}

				TimeComplexity -> O(2N)
				SpaceComplexity -> O(N)
				public static void rearrangeArrayPosNotEqualToNeg(int arr[]) {
					// [3,1,-2,-5,2,-4,6,8]
					// [3,1,2,6,8]
					// [-2,-5,-4]
					// 3 , -2,1,-5,2,-4
					List<Integer> pos = new ArrayList<>();
					List<Integer> neg = new ArrayList<>();
					for (int i = 0; i < arr.length; i++) {
						if (arr[i] > 0) {
							pos.add(arr[i]);
						} else {
							neg.add(arr[i]);
						}
					}

					if (pos.size() > neg.size()) {
						int index = 0;
						for (int i = 0; i < neg.size(); i++) {
							arr[2 * i] = pos.get(i);
							arr[2 * i + 1] = neg.get(i);
							index++;
						}
						for (int i = neg.size(); i < pos.size(); i++) {
							arr[index] = pos.get(i);
						}
					} else {
						int index = 0;
						for (int i = 0; i < pos.size(); i++) {
							arr[2 * i] = neg.get(i);
							arr[2 * i + 1] = pos.get(i);
							index++;
						}
						for (int i = pos.size(); i < neg.size(); i++) {
							arr[index] = neg.get(i);
						}
					}
					logArray(arr);
				}
		
		Next Permutation ->
			1,2,3 -> All possible permutations are 
				1 3 2
				2 1 3
				2 3 1
				3 1 2
				3 2 1

			Optimal approach ->
				1. Search the breakPoint where arr[i]<arr[i+1] i.e arr[1]<arr[2] then
					breakpoint will be index 1
				2. If breakpoint doesn't exists then it means it has the largest possible combination,
					so just reverse the array and return it
				3. Now search for the element which is greater then the breakpoint element
					and swap it
				3. Now reverse the array from breakpoint to the right
				TimeComplexity -> O(n) for each loops and Reversing
				SpaceComplexity -> O(n)

				public static int[] nextPermutation(int arr[]) {
					int breakPoint = -1;
					int i = arr.length - 1;
					// 1. Search the breakPoint where arr[i]<arr[i+1] i.e arr[1]<arr[2] then
					// breakpoint will be index 1
					while (i > 0) {
						if (arr[i - 1] < arr[i]) {
							breakPoint = i - 1;
							break;
						}
						i--;
					}
					// if breakpoint doesn't exists then it means it has the largest possible combination,
					// so just reverse the array and return it
					if (breakPoint == -1) {
						reverseArray(arr, 0, arr.length - 1);
						return arr;
					}
					// 2. Now search for the element which is greater then the breakpoint element
					// and swap it
					for (int j = arr.length - 1; j > breakPoint; j--) {
						if (arr[j] > arr[breakPoint]) {
							swap(arr, breakPoint, j);
							break;
						}
					}
					// 3. Now reverse the array from breakpoint to the right
					reverseArray(arr, breakPoint + 1, arr.length - 1);
					logArray(arr);
					return arr;
				}
	
		Leaders in an Array ->
			Brute Force approach -> using two loops and continuing while it is larger then rest 
			of the elements
				TimeComplexity -> O(N^2)
				SpaceComplexity -> O(1)
			
			Optimal approach ->
				public static ArrayList<Integer> leadersInArray(int arr[]) {

					ArrayList<Integer> ans = new ArrayList<>();
					if (arr.length == 0) {
						return ans;
					} else {
						ans.add(arr[arr.length - 1]);
					}
					for (int i = arr.length - 2; i >= 0; i--) {
						if (arr[i] > ans.get(ans.size() - 1)) {
							ans.add(arr[i]);
						}
					}
					Collections.reverse(ans);
					return ans;
				}
				TimeComplexity -> O(n)
				SpaceComplexity- > O(1)

		Longest consecutive sequence in an Array ->
			Here consecutive means difference of adjacent elements must be 1
			arr = 1 2 3 4 100 101 102
			here consecutive subsequences are 1 2 3 4  and 101 102 103  
			
			Better approach ->
			public static void longestConsecutiveSubsequence(ArrayList<Integer> arr) {
				int count = 0, lastSmaller = Integer.MIN_VALUE, longest = 0;
				Collections.sort(arr);
				System.out.println(arr);
				for (int i = 0; i < arr.size(); i++) {
					if (arr.get(i) - 1 == lastSmaller) {
						count++;
						lastSmaller = arr.get(i);
					} else if (arr.get(i) != lastSmaller) {
						count = 1;
						lastSmaller = arr.get(i);
					}
					longest = Math.max(longest, count);
				}
				System.out.println("longest subsequence is " + longest);
			}
			TimeComplexity -> O(nLogN)+O(N)
			SpaceComplexity -> O(1)

		Set Matrix Zero ->
			When a zero is encountered set its row and col element as 0

				Brute force approach ->
					Loop and if zero is encountered replace its row and col with -1
					then traverse the matrix again and set -1 as 0
					TimeComplexity -> O(n^3)
				
				Better approach -> using two arrays of size m and N
					if element is 0 mark its row and col and 1 
					reiterate and if the row/col is marked as 1 replace it with 0
					TimeComplexity -> O(2 * n * m)
					SpaceComplexity -> O(n)+O(m)

				Optimal approach ->
					public class Main {
						static ArrayList<ArrayList<Integer>> zeroMatrix(ArrayList<ArrayList<Integer>> matrix, int n, int m) {
							// int[] row = new int[n]; --> matrix[..][0]
							// int[] col = new int[m]; --> matrix[0][..]
							int col0 = 1;
							// step 1: Traverse the matrix and
							// mark 1st row & col accordingly:
							for (int i = 0; i < n; i++) {
								for (int j = 0; j < m; j++) {
									if (matrix.get(i).get(j) == 0) {
										// mark i-th row:
										matrix.get(i).set(0, 0);

										// mark j-th column:
										if (j != 0)
											matrix.get(0).set(j, 0);
										else
											col0 = 0;
									}
								}
							}

							// Step 2: Mark with 0 from (1,1) to (n-1, m-1):
							for (int i = 1; i < n; i++) {
								for (int j = 1; j < m; j++) {
									if (matrix.get(i).get(j) != 0) {
										// check for col & row:
										if (matrix.get(i).get(0) == 0 || matrix.get(0).get(j) == 0) {
											matrix.get(i).set(j, 0);
										}
									}
								}
							}
							//step 3: Finally mark the 1st col & then 1st row:
							if (matrix.get(0).get(0) == 0) {
								for (int j = 0; j < m; j++) {
									matrix.get(0).set(j, 0);
								}
							}
							if (col0 == 0) {
								for (int i = 0; i < n; i++) {
									matrix.get(i).set(0, 0);
								}
							}

							return matrix;
						}

						public static void main(String[] args) {
							ArrayList<ArrayList<Integer>> matrix = new ArrayList<>();
							matrix.add(new ArrayList<>(Arrays.asList(1, 1, 1)));
							matrix.add(new ArrayList<>(Arrays.asList(1, 0, 1)));
							matrix.add(new ArrayList<>(Arrays.asList(1, 1, 1)));

							int n = matrix.size();
							int m = matrix.get(0).size();

							ArrayList<ArrayList<Integer>> ans = zeroMatrix(matrix, n, m);

							System.out.println("The Final matrix is: ");
							for (ArrayList<Integer> row : ans) {
								for (Integer ele : row) {
									System.out.print(ele + " ");
								}
								System.out.println();
							}
						}
					}
					TimeComplexity -> O(2*n*m)
					SpaceComplexity -> O(1)

		Rotate matrix by 90 deg ->
			Brute force approach ->
				for (int i = 0; i < m; i++) {
					for (int j = 0; j < n; j++) {
						arr2[j][n - 1 - i] = arr[i][j];
					}
				}
				TimeComplexity -> O(n^2)
				SpaceComplexity -> O(n^2)
			
			Better approach ->
				using Transpose and then Reversing
				 for (int i = 0; i < m; i++) {
					for (int j = 0; j < n; j++) {
						if (i != j) {
							// swap
							int t = arr[i][j];
							arr[i][j] = arr[j][i];
							arr[j][i] = t;
						}
					}
				}

				TimeComplexity -> O(N)
				SpaceComplexity -> O(1)

		Spiral Array output ->
			Optimal approach ->
			TimeComplexity ->O(n*m)
			SpaceComplexity -> O(1)
				int top = 0, bottom = arr.length - 1, left = 0, right = arr[0].length - 1;
				System.out.println(top + "" + bottom + "" + left + "" + right);

				while (left <= right && top <= bottom) {
					// left to right keeping top constant
					for (int i = left; i <= right; i++) {
						System.out.print(arr[top][i] + " ");
					}
					top++;
					// top to bottom keeping right constant
					for (int i = top; i <= bottom; i++) {
						System.out.print(arr[i][right] + " ");
					}
					right--;

					if (top <= bottom) {
						// right to left keeping bottom constant
						for (int i = right; i >= left; i--) {
							System.out.print(arr[bottom][i] + " ");
						}
						bottom--;
					}
					if (left <= right) {
						// bottom to top keeping left constant
						for (int i = bottom; i >= top; i--) {
							System.out.print(arr[i][left] + " ");
						}
						left++;
					}
				}

		Pascal's Triangle ->
			To find the element of given Row and Col we use nCr
			Row-1 C col-1
			
			Optimal approach ->
				TimeComplexity -> O(r)
				public static int ncr(int n, int r) {
					int ans = 1;
					for (int i = 0; i < r; i++) {
						ans = ans * (n - i);
						ans = ans / (i + 1);
					}
					return ans;
				}
				TimeComplexity -> O(N)
				public static void printRowOfPascalTraiangle(int rows) {
					int ans = 1;
					if (rows == 1) {
						System.out.println(ans + " ");
						return;
					}
					System.out.print(ans + " ");
					for (int i = 1; i < rows; i++) {
						ans = ans * (rows - i);
						ans = ans / (i);
						System.out.print(ans + " ");
					}
					System.out.println("");
				}

				public static void pascalsTriangle(int rowLength) {

					for (int i = 1; i <= rowLength; i++) {
						printRowOfPascalTraiangle(i);
					}
				}

		3Sum Problem ->

			Brute force approach -> 
				using three loops and generating all possible combinations of subarrays
				TimeComplexity -> O(N^3)
				SpaceComplexity -> O(1)

			Optimal approach -> Using two pointer method
				*Works when array is sorted
				TimeComplexity -> O(n^2)+O(nLogN)
				SpaceComplexity -> O(1)

				public static void threeSum(int arr[], int target) {
					int sum = 0;
					Arrays.sort(arr);
					for (int i = 0; i < arr.length; i++) {
						if (i != 0 && arr[i] == arr[i - 1])
							continue;
						int j = i + 1, k = arr.length - 1;
						while (j < k) {
							sum = arr[i] + arr[j] + arr[k];
							if (sum > target) {
								k--;
							} else if (sum < target) {
								j++;
							} else {
								System.out.println("Elements are [" + arr[i] + " " + arr[j] + " " + arr[k] + "]");
								j++;
								k--;
								while (j < k && arr[j] == arr[j - 1])
									j++;
								while (j < k && arr[k] == arr[k + 1])
									k--;
							}
						}
					}
				}
		
		4Sum Problem ->
			Optimal approach -> using two pointer approach
				TimeComplexity -> O(n^3)+ O(nLogN)
				SpaceComplexity -> O(1)
				public List<List<Integer>> fourSum(int[] nums, int target) {
					List<List<Integer>> result = new ArrayList<>();
					Arrays.sort(nums);
					for (int i = 0; i < nums.length; i++) {

						if (i != 0 && nums[i] == nums[i - 1])
							continue;
						for (int j = i + 1; j < nums.length; j++) {
							if (j != i + 1 && nums[j] == nums[j - 1])
								continue;

							int k = j + 1, l = nums.length - 1;
							while (k < l) {
								long sum = 0;
								sum += nums[i];
								sum += nums[j];
								sum += nums[k];
								sum += nums[l];
								if (sum > target) {
									l--;
								} else if (sum < target) {
									k++;
								} else {
									List<Integer> temp = Arrays.asList(nums[i], nums[j], nums[k], nums[l]);
									result.add(temp);
									k++;
									l--;
									while (k < l && nums[k] == nums[k - 1])
										k++;
									while (k < l && nums[l] == nums[l + 1])
										l--;
								}
							}
						}
					}
					return result;
				}
		
		No. of subarray with given sum K ->
			Brute force approach -> using two loops
				TimeComplexity -> O(N^2)
				SpaceComplexity -> O(1) 
			Optimal approach -> using hashing
				TimeComplexity -> O(N)
				SpaceComplexity -> O(N)
				public static void numberOfSubarraysWithGivenSumK(int arr[], int k) {

					HashMap<Integer, Integer> prefixSum = new HashMap<>();

					prefixSum.put(0, 1);
					int sum = 0;
					int count = 0;
					for (int i = 0; i < arr.length; i++) {
						sum += arr[i];

						if (prefixSum.containsKey(sum - k)) {
							count += prefixSum.get(sum - k);
						}

						if (!prefixSum.containsKey(sum)) {
							prefixSum.put(sum, 1);
						} else {
							prefixSum.put(sum, prefixSum.get(sum) + 1);
						}

						// prefixSum.put(sum, prefixSum.getOrDefault(sum, 0) + 1);
					}
					System.out.println("number of subarrays are "+count);
				}
		
		No. of subarray with given XOR K ->
			Optimal approach -> using Hashing
			For frequency count store (0,1) in the HashMap
			For XOR instead of sum just do the XOR
				sum=sum+arr[i]  --------> sum=sum^arr[i]

			For remaining ->
				remaining=sum-k;
				remaining=sum^k;

  		Merge overlapping sub-intervals ->
			Brute force approach ->
				Sort the pairs 
				1,3 -> 2,4
				Here 2 <3 so interval overlaps
				TimeComplexity -> O(nLogN)+ O(N^2)
				public static List<List<Integer>> mergeOverlappingIntervals(int[][] arr) {
						List<List<Integer>> ans = new ArrayList<>();
						Arrays.sort(arr, (int a[], int b[]) -> a[0] - b[0]);
						for (int i = 0; i < arr.length; i++) {
							int start = arr[i][0];
							int end = arr[i][1];
							if (!ans.isEmpty() && end <= ans.get(ans.size() - 1).get(1)) {
								continue;
							}
							for (int j = i + 1; j < arr.length; j++) {
								if (arr[j][0] <= end) {
									end = Math.max(end, arr[j][0]);
								} else {
									break;
								}
							}
							ans.add(Arrays.asList(start, end));
						}
						System.out.println(ans);
						return ans;
					}
			Optimal approach ->
				TimeComplexity -> O(nLogN)+O(N)
				SpaceComplexity -> O(N)
			 	After Sorting
					for (int i = 0; i < arr.length; i++) {
					// When no ans is present and if ongerval doesn't overlaps
					if (ans.isEmpty() || arr[i][0] > ans.get(ans.size() - 1).get(1)) {
						ans.add(Arrays.asList(arr[i][0], arr[i][1]));
					}
					// when it overlaps;
					else {
						ans.get(ans.size() - 1).set(1, Math.max(ans.get(ans.size() - 1).get(1), arr[i][1]));
					}
				}
				return ans;

		Merge two sorted Arrays w/o third array ->

			TimeComplexity -> O(min(m,n))+O(nLogN)+O(mLogM)
			SpaceComplexity ->O(1)
			public void merge(int[] nums1, int m, int[] nums2, int n) {
				int left=m-1;
				int right=0;
				while(left>=0 && right<n){
					if(nums1[left]>nums2[right]){
						// swap(nums[left],nums[right]);
						int temp=nums1[left];
						nums1[left]=nums2[right];
						nums2[right]=temp;
						left--;
						right++;
					}
					else{
						break;
					}
				}
				Arrays.sort(nums1);
				Arrays.sort(nums2);
			}

9. Binary Search ->
		Used to search number in a SORTED array
		*Overflow would be when we are at last element , here mid will be
			int mid= (Integer.MAX_VALUE+Integer.MAX_VALUE)/2 which will Overflow
			to solve this either use long low, mid, high
			or use int mid=low+(hgih-low)/2
		1. Using loop ->
			TimeComplexity -> O(logN)
			SpaceComplexity -> O(1)
			public static int binarySearch(int arr[], int k) {
				int low = 0, high = arr.length - 1;
				while (low <= high) {
					int mid = (low + high) / 2;
					if (arr[mid] == k) {
						return mid;
					} else if (arr[mid] > k) {
						high = mid-1;
					} else {
						low = mid + 1;
					}
				}
				return -1;
			}

		2. Using recursion ->
			TimeComplexity -> O(logN)
			SpaceComplexity -> O(1)
			public static int binarySearchUsingRecursion(int arr[], int low, int high, int k) {
				if (low >= high) {
					return -1;
				}
				int mid = (low + high) / 2;
				if (arr[mid] == k) {
					return mid;
				} else if (arr[mid] < k) {
					return binarySearchUsingRecursion(arr, low, mid - 1, k);
				} else {
					return binarySearchUsingRecursion(arr, mid + 1, high, k);
				}
			}
		3. Types of Questions ->
			Lower Bound ->
				* smallest index where Arr[index] >= x then it can be my ans but it must be at index lowest
				 public static int binarySearchLowerBound(int arr[], int k) {
					int low = 0, high = arr.length - 1;
					int ans = arr.length;
					while (low <= high) {
						int mid = (low + high) / 2;
						if (arr[mid] >= k) {
							ans = mid;
							high = mid - 1;
						} else {
							low = mid + 1;
						}
					}
					return ans;
				}

			Upper Bound ->
				* smallest index where Arr[index] > x\
			
			First Occurence ->
				public static int binarySearchFirstOccurence(int arr[], int target) {
					int low = 0, high = arr.length - 1;
					int first = -1;
					while (low <= high) {
						int mid = (low + high) / 2;
						if (arr[mid] == target) {
							first = mid;
							high = mid - 1;
						} else if (arr[mid] < target) {
							low = mid + 1;
						} else {
							high = mid - 1;
						}
					}
				
			Last Occurence ->
				public static int binarySearchLastOccurence(int arr[], int target) {
					int low = 0, high = arr.length - 1;
					int last = -1;
					while (low <= high) {
						int mid = (low + high) / 2;
						if (arr[mid] == target) {
							last = mid;
							low = mid + 1;
						} else if (arr[mid] < target) {
							low = mid + 1;
						} else {
							high = mid - 1;
						}
					}
					System.out.println("Last occurence of " + target + " is " + last);
					return last;
				}

			Search in Sorted Rotated array ->
				* Eliminate sorted half and reduce the array
				TimeComplexity -> O(logn)
				 public static int searchInSortedRotatedArrayUsingBinarySearch(int arr[], int target) {
					int low = 0, high = arr.length - 1;
					while (low <= high) {
						int mid = (low + high) / 2;
						if (arr[mid] == target) {
							return mid;
						}
						// identify the sorted half
						// if left half is sorted
						else if (arr[low] <= arr[mid]) {
							if (arr[low] <= target && target <= arr[mid]) {
								high = mid - 1;
							} else {
								low = mid + 1;
							}
						}
						// if right half is sorted
						else {
							if (arr[mid] <= target && target <= arr[high]) {
								high = mid - 1;
							} else {
								low = mid + 1;
							}
						}
					}
					return -1;
				}
				*If elements repeat then shrink the boundary
					extend low and reduce high
					if (arr[low] == arr[mid] && arr[mid] == arr[high]) {
						low = low + 1;
						high = high - 1;
						continue;
					}
			
			Minimum in sorted array ->
				Search the sorted portion and choose the minimum and eleminate that half
				public static int mimimumInSortedArrayUsingBinarySearch(int arr[]) {
					int low = 0, high = arr.length - 1, ans = Integer.MAX_VALUE;

					while (low <= high) {
						int mid = (low + high) / 2;

						// When we get a sorted portion no need to again divide the array in two halves
						if(arr[low]<=arr[high]){
							ans=Math.min(ans,arr[low]);
							break;
						}
						if (arr[low] <= arr[mid]) {
							ans = Math.min(ans, arr[low]);
							low = mid + 1;
						} else {
							ans = Math.min(ans, arr[mid]);
							high = mid - 1;
						}
					}
					return ans;
				}

			Single element in Sorted array ->
				1,1,2,2,3,3,4,5,5,6,6
				ans is 4
				*Observations - 
					left half -> index pairs -(even,odd) & element is in right half
					right half -> index pairs -(odd,even) & element is in left half
			
			Peak element ->
				*Observations ->
					for peak element left -> has increasing order
					peak element right has decreasing order

					if we are in left half then element is in right half vice versa
				public static int peakElement(int arr[]) {

					int n = arr.length - 1;
					int low = 0, high = n - 2;

					if (n == 1) {
						return arr[0];
					}
					if (arr[0] > arr[1]) {
						return arr[0];
					}
					if (arr[n - 1] > arr[n - 2]) {
						return arr[n - 1];
					}

					while (low <= high) {
						int mid = (low + high) / 2;
						if (arr[mid] < arr[mid - 1] && arr[mid] > arr[mid + 1]) {
							return arr[mid];
						}
						// left half has increasing order
						else if (arr[mid - 1] > arr[mid]) {
							low = mid + 1;
						} else {
							high = mid - 1;
						}
					}
					return -1;
				}